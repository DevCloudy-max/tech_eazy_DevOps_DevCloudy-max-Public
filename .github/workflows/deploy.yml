name: Deploy Java application via Terraform

on:
    push:
        branches:
            - main
            - feature/pipline-enhancement
        tags:
            - 'deploy-dev'
            - 'deploy-prod'
    
jobs:
    Terraform-deployment:
        name: terraform deploy
        runs-on: ubuntu-latest

        env:
            AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
            AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
            
        steps:
            - name: Checkout code
              uses: actions/checkout@v3

            - name: Setup Terrraform
              uses: hashicorp/setup-terraform@v2
              with:
                terraform_version: 1.6.6

            - name: Determine stage
              id: get-stage
              run: |
               if [[ "${GITHUB_REF}" == "refs/heads/main" ]]; then
                  echo "stage=dev" >> "$GITHUB_OUTPUT"

               elif [[ "${GITHUB_REF}" == "refs/heads/feature/pipline-enhancement" ]]; then
                  echo "stage=dev" >> "$GITHUB_OUTPUT"

               elif [[ "${GITHUB_REF}" == "refs/tags/deploy-prod" ]]; then
                  echo "stage=prod" >> "$GITHUB_OUTPUT"

               
               elif [[ "${GITHUB_REF}" == "refs/tags/deploy-dev" ]]; then
                  echo "stage=dev" >> "$GITHUB_OUTPUT"
               else
                  echo "Unsupported ref: ${GITHUB_REF}"
                  exit 1
               fi
            
            - name: Terraform Init
              run: terraform init

            - name: Import ec2-write-only-profile (IAM instance profile)
              run: terraform import -input=false -var-file="${{ steps.get-stage.outputs.stage }}_config.tfvars" aws_iam_instance_profile.ec2_instance_profile ec2-write-only-profile || true

            - name: Import ec2-read-only-profile (IAM instance profile)
              run: terraform import -input=false -var-file="${{ steps.get-stage.outputs.stage }}_config.tfvars" aws_iam_instance_profile.read_instance_profile ec2-read-only-profile || true

            - name: Terraform Formating
              run: terraform fmt -check
              
            - name: Terrraform syntax validation
              run: terraform validate

            - name: Terraform plan
              run: terraform plan -var-file="${{ steps.get-stage.outputs.stage }}_config.tfvars"

            - name: Terraform Apply
              run: terraform apply -auto-approve -var-file="${{ steps.get-stage.outputs.stage }}_config.tfvars"

            - name: Get EC2 Public IP
              id: get-ec2-ip
              run: |
                 # Extract clean IP from terraform output
                  IP=$(terraform output -raw aws_Main_instance_Public_Ip | grep -Eo '([0-9]{1,3}\.){3}[0-9]{1,3}')
                  
                  # Export to GitHub environment variable
                  echo "EC2_PUBLIC_IP=$IP" >> $GITHUB_ENV

                  # Optional: print for logs
                  echo "EC2_PUBLIC_IP=$IP"

            
              #run this for loop 15 times but after each loop stop for 10 sec then agian iterate
            - name: Wait for EC2 to be ready on port 80 !!!
              run: |

                 set +e

                  echo "EC2 IP from ENV: $EC2_PUBLIC_IP"

                  echo "Sleeping 60 seconds to let app boot..."
                  sleep 60

                  for i in {1..15}; do
                    echo "Try $i: Curling http://$EC2_PUBLIC_IP with -v"
                    curl -v http://$EC2_PUBLIC_IP || true
                    STATUS=$(curl -s -o /dev/null -w "%{http_code}" http://$EC2_PUBLIC_IP)
                    echo "HTTP Status: $STATUS"

                    if [[ "$STATUS" == "200" ]]; then
                      echo "‚úÖ App reachable!"
                      exit 0
                    fi
                    echo "‚è≥ Not ready, retrying..."
                    sleep 10
                  done

                  echo "‚ùå App not reachable after 15 tries."
                  exit 1
              env:
                EC2_PUBLIC_IP: ${{ env.EC2_PUBLIC_IP }}
              #  set +e 
              #   export EC2_PUBLIC_IP=$(terraform output -raw aws_Main_instance_Public_Ip)
              #   echo "EC2 Public IP: $EC2_PUBLIC_IP"

              #   # Add an initial sleep to give the application more time to start
              #   echo "Giving application an initial 30 seconds to start..."
              #   sleep 100

              #   for i in {1..15}; do
              #     echo "Attempt $i: Checking port 80..."
              #     # Add --connect-timeout and -m (max-time) to curl for robustness
              #     STATUS=$(curl --head --silent http://$EC2_PUBLIC_IP/ | grep "200")
              #     echo "HTTP Status: $STATUS"

              #     if [[ "$STATUS" == "200" ]]; then
              #       echo "‚úÖ App is reachable on port 80!"
              #       exit 0
              #     else
              #       echo "‚è≥ Not ready yet, retrying in 10s..."
              #       sleep 10
              #     fi
              #   done

              #   echo "‚ùå App is not reachable on port 80 after multiple attempts."
              #   exit 1
            
            - name: ‚è≥ Wait 10 minutes before destroying
              if: steps.get-stage.outputs.stage == 'dev' 
              run: |
                echo "Waiting 10 minutes before automatic destroy..."
                sleep 700 

            - name: üß® Terraform Destroy (Auto cleanup for dev)
              if: steps.get-stage.outputs.stage == 'dev' 
              run: terraform destroy -auto-approve -var-file="${{ steps.get-stage.outputs.stage }}_config.tfvars"


